digraph MatmulComputeGraphMultiBuffer {
    rankdir=TB;
    bgcolor="white";
    pad=0.5;
    dpi=300;

    // Graph styling
    node [fontname="Arial", fontsize=11, style="filled,rounded", shape=box];
    edge [fontname="Arial", fontsize=9];

    // Title
    label="Compute Graph: Multi-Buffer Transformation\nL[M,K] @ R[K,N] = Output[M,N]\nMulti-Buffer: L_sbuf_multi allocated once, partitioned for sg1 & sg2";
    labelloc="t";
    fontsize=14;
    fontname="Arial Bold";

    // Subgraph 0: unchanged
    subgraph cluster_0 {
        label="Subgraph 0\n(M_tile=0, N_tile=0)";

        alloc_L_0 [label="L_sbuf_0 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_R_0 [label="R_sbuf_0 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_out_0 [label="out_sbuf_0 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        load_L_0 [label="nl.load(L[0, :],\ndst=L_sbuf_0)", fillcolor="#FFEAA7"];
        load_R_0 [label="nl.load(R[:, 0],\ndst=R_sbuf_0)", fillcolor="#FFEAA7"];
        compute_0 [label="nl.matmul(L_sbuf_0,\nR_sbuf_0, out_sbuf_0)", fillcolor="#A8D8EA"];
        store_0 [label="nl.store(out_sbuf_0,\ndst=Output[0,0])", fillcolor="#A8E6CF"];

        alloc_L_0 -> load_L_0 [label="L_sbuf_0", color="#666666"];
        alloc_R_0 -> load_R_0 [label="R_sbuf_0", color="#666666"];
        alloc_out_0 -> compute_0 [label="out_sbuf_0", color="#666666"];
        load_L_0 -> compute_0 [label="L_sbuf_0", color="#666666"];
        load_R_0 -> compute_0 [label="R_sbuf_0", color="#666666"];
        compute_0 -> store_0 [label="out_sbuf_0", color="#666666"];
    }

    // Merged subgraph 1+2: parallel with multi-buffer allocation
    subgraph cluster_merged_12 {
        label="Merged Subgraph 1+2 (parallel with multi-buffer)";
        penwidth=2;
        color="#4169E1";

        // Multi-buffer allocate node (2x size, shared by both subgraphs)
        alloc_L_multi [label="L_sbuf_multi =\nnl.ndarray([2, ...])", fillcolor="#E8E8E8", penwidth=3, style="filled,rounded,bold"];
        alloc_R_1 [label="R_sbuf_1 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_out_1 [label="out_sbuf_1 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_R_2 [label="R_sbuf_2 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_out_2 [label="out_sbuf_2 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];

        // Subgraph 1 operations (uses partition [0])
        load_L_1 [label="nl.load(L[0, :],\ndst=L_sbuf_multi[0])", fillcolor="#FFEAA7", penwidth=2];
        load_R_1 [label="nl.load(R[:, 1],\ndst=R_sbuf_1)", fillcolor="#FFEAA7"];
        compute_1 [label="nl.matmul(L_sbuf_multi[0],\nR_sbuf_1, out_sbuf_1)", fillcolor="#A8D8EA", penwidth=2];
        store_1 [label="nl.store(out_sbuf_1,\ndst=Output[0,1])", fillcolor="#A8E6CF"];

        // Subgraph 2 operations (uses partition [1])
        load_L_2 [label="nl.load(L[1, :],\ndst=L_sbuf_multi[1])", fillcolor="#FFEAA7", penwidth=2];
        load_R_2 [label="nl.load(R[:, 0],\ndst=R_sbuf_2)", fillcolor="#FFEAA7"];
        compute_2 [label="nl.matmul(L_sbuf_multi[1],\nR_sbuf_2, out_sbuf_2)", fillcolor="#A8D8EA"];
        store_2 [label="nl.store(out_sbuf_2,\ndst=Output[1,0])", fillcolor="#A8E6CF"];

        // Allocate edges (multi-buffer connects to both loads)
        alloc_L_multi -> load_L_1 [label="L_sbuf_multi", color="#666666", penwidth=2];
        alloc_L_multi -> load_L_2 [label="L_sbuf_multi", color="#666666", penwidth=2];
        alloc_R_1 -> load_R_1 [label="R_sbuf_1", color="#666666"];
        alloc_out_1 -> compute_1 [label="out_sbuf_1", color="#666666"];
        alloc_R_2 -> load_R_2 [label="R_sbuf_2", color="#666666"];
        alloc_out_2 -> compute_2 [label="out_sbuf_2", color="#666666"];

        // Internal edges for sg1
        load_L_1 -> compute_1 [label="L_sbuf_multi[0]", color="#666666"];
        load_R_1 -> compute_1 [label="R_sbuf_1", color="#666666"];
        compute_1 -> store_1 [label="out_sbuf_1", color="#666666"];

        // Internal edges for sg2
        load_L_2 -> compute_2 [label="L_sbuf_multi[1]", color="#666666"];
        load_R_2 -> compute_2 [label="R_sbuf_2", color="#666666"];
        compute_2 -> store_2 [label="out_sbuf_2", color="#666666"];
    }

    // Subgraph 3: unchanged
    subgraph cluster_3 {
        label="Subgraph 3\n(M_tile=1, N_tile=1)";

        alloc_L_3 [label="L_sbuf_3 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_R_3 [label="R_sbuf_3 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        alloc_out_3 [label="out_sbuf_3 =\nnl.ndarray(...)", fillcolor="#E8E8E8"];
        load_L_3 [label="nl.load(L[1, :],\ndst=L_sbuf_3)", fillcolor="#FFEAA7"];
        load_R_3 [label="nl.load(R[:, 1],\ndst=R_sbuf_3)", fillcolor="#FFEAA7"];
        compute_3 [label="nl.matmul(L_sbuf_3,\nR_sbuf_3, out_sbuf_3)", fillcolor="#A8D8EA"];
        store_3 [label="nl.store(out_sbuf_3,\ndst=Output[1,1])", fillcolor="#A8E6CF"];

        alloc_L_3 -> load_L_3 [label="L_sbuf_3", color="#666666"];
        alloc_R_3 -> load_R_3 [label="R_sbuf_3", color="#666666"];
        alloc_out_3 -> compute_3 [label="out_sbuf_3", color="#666666"];
        load_L_3 -> compute_3 [label="L_sbuf_3", color="#666666"];
        load_R_3 -> compute_3 [label="R_sbuf_3", color="#666666"];
        compute_3 -> store_3 [label="out_sbuf_3", color="#666666"];
    }
}
